Description: Modify the authentication
 Use the deepin-deb-installer to install the software for the first time must be authenticated when deepin-deb-installer opened every time. If the interval between later installation of the software package and the first installation dose not exceed the set time, authentication is not required. After the time has expired, authenticate again and update the authentication time.
Author: qinxialei <qinxialei@uniontecj.com>
Forwarded: not-needed
Last-Update: 2021-10-12

Index: libqapt-3.0.4.6/src/worker/transaction.cpp
===================================================================
--- libqapt-3.0.4.6.orig/src/worker/transaction.cpp
+++ libqapt-3.0.4.6/src/worker/transaction.cpp
@@ -31,6 +31,7 @@
 #include "transactionadaptor.h"
 #include "transactionqueue.h"
 #include "worker/urihelper.h"
+#include "workerdaemon.h"
 
 #define IDLE_TIMEOUT 30000 // 30 seconds
 
@@ -85,6 +86,56 @@ Transaction::Transaction(TransactionQueu
             this, SLOT(emitIdleTimeout()));
 }
 
+Transaction::Transaction(TransactionQueue *queue, int userId,
+                         QApt::TransactionRole role, QVariantMap packagesList,
+                         WorkerDaemon *workerdaemon)
+    : QObject(queue)
+    , m_queue(queue)
+    , m_uid(userId)
+    , m_role(role)
+    , m_status(QApt::SetupStatus)
+    , m_error(QApt::Success)
+    , m_packages(packagesList)
+    , m_isCancellable(true)
+    , m_isCancelled(false)
+    , m_exitStatus(QApt::ExitUnfinished)
+    , m_isPaused(false)
+    , m_progress(0)
+    , m_allowUntrusted(false)
+    , m_downloadSpeed(0)
+    , m_safeUpgrade(true)
+    , m_replaceConfFile(false)
+    , m_frontendCaps(QApt::NoCaps)
+    , m_dataMutex(QMutex::Recursive)
+{
+    new TransactionAdaptor(this);
+    QDBusConnection connection = QDBusConnection::systemBus();
+
+    QString tid = QUuid::createUuid().toString();
+    // Remove parts of the uuid that can't be part of a D-Bus path
+    tid.remove('{').remove('}').remove('-');
+    m_tid = "/org/kubuntu/qaptworker/transaction" + tid;
+    //m_timeT = 0; //初始化时间戳
+
+    m_workerDaemon = workerdaemon;
+
+    if (!connection.registerObject(m_tid, this))
+        qWarning() << "Unable to register transaction on DBus";
+
+    m_roleActionMap[QApt::EmptyRole] = QString("");
+    m_roleActionMap[QApt::UpdateCacheRole] = dbusActionUri("updatecache");
+    m_roleActionMap[QApt::UpgradeSystemRole] = dbusActionUri("commitchanges");
+    m_roleActionMap[QApt::CommitChangesRole] = dbusActionUri("commitchanges");
+    m_roleActionMap[QApt::DownloadArchivesRole] = QString("");
+    m_roleActionMap[QApt::InstallFileRole] = dbusActionUri("commitchanges");
+
+    m_queue->addPending(this);
+    m_idleTimer = new QTimer(this);
+    m_idleTimer->start(IDLE_TIMEOUT);
+    connect(m_idleTimer, SIGNAL(timeout()),
+            this, SLOT(emitIdleTimeout()));
+}
+
 Transaction::~Transaction()
 {
     QDBusConnection::systemBus().unregisterObject(m_tid);
@@ -531,7 +582,19 @@ bool Transaction::authorizeRun()
 
     setStatus(QApt::AuthenticationStatus);
 
-    return QApt::Auth::authorize(action, m_service);
+    if (m_workerDaemon->judgeAuthen())
+    {
+        if(QApt::Auth::authorize(action, m_service))
+        {
+            m_workerDaemon->setTransTimer(QDateTime::currentMSecsSinceEpoch());
+            return true;
+        }
+        return false;
+    }
+    else
+    {
+        return true;
+    }
 }
 
 void Transaction::setProperty(int property, QDBusVariant value)
Index: libqapt-3.0.4.6/src/worker/transaction.h
===================================================================
--- libqapt-3.0.4.6.orig/src/worker/transaction.h
+++ libqapt-3.0.4.6/src/worker/transaction.h
@@ -33,6 +33,7 @@
 
 class QTimer;
 class TransactionQueue;
+class WorkerDaemon;
 
 class Transaction : public QObject, protected QDBusContext
 {
@@ -67,6 +68,8 @@ public:
     Transaction(TransactionQueue *queue, int userId);
     Transaction(TransactionQueue *queue, int userId,
                 QApt::TransactionRole role, QVariantMap packagesList);
+    Transaction(TransactionQueue *queue, int userId,
+                QApt::TransactionRole role, QVariantMap packagesList, WorkerDaemon *workerDaemon);
     ~Transaction();
 
     QString transactionId() const;
@@ -151,6 +154,7 @@ private:
     QString m_currentConfPath;
     bool m_replaceConfFile;
     QApt::FrontendCaps m_frontendCaps;
+    WorkerDaemon *m_workerDaemon;
 
     QVariantMap m_envVariable;
 
Index: libqapt-3.0.4.6/src/worker/workerdaemon.cpp
===================================================================
--- libqapt-3.0.4.6.orig/src/worker/workerdaemon.cpp
+++ libqapt-3.0.4.6/src/worker/workerdaemon.cpp
@@ -23,6 +23,7 @@
 // Qt includes
 #include <QtCore/QThread>
 #include <QtCore/QTimer>
+#include <QProcess>
 
 // Apt-pkg includes
 #include <apt-pkg/configuration.h>
@@ -35,7 +36,7 @@
 #include "workeradaptor.h"
 #include "urihelper.h"
 
-#define IDLE_TIMEOUT 30000 // 30 seconds
+#define IDLE_TIMEOUT 60*60*1000 // 30 seconds
 
 WorkerDaemon::WorkerDaemon(int &argc, char **argv)
     : QCoreApplication(argc, argv)
@@ -46,6 +47,10 @@ WorkerDaemon::WorkerDaemon(int &argc, ch
     m_worker = new AptWorker(nullptr);
     m_queue = new TransactionQueue(this, m_worker);
 
+    m_TransTimer = 0;
+    m_Deepin_deb_installer_PID = 0;
+    m_IDLE_TIMEOUT = getIdleTimeout()*1000;
+
     m_workerThread = new QThread(this);
     m_worker->moveToThread(m_workerThread);
     m_workerThread->start();
@@ -96,12 +101,67 @@ int WorkerDaemon::dbusSenderUid() const
     return connection().interface()->serviceUid(message().service()).value();
 }
 
+void WorkerDaemon::setTransTimer(quint64 timer)
+{
+    m_TransTimer = timer;
+}
+
+int WorkerDaemon::getIdleTimeout()
+{
+    QString confpath("/etc/libqapt3/libqapt3.conf");
+    //the timeout default value is 30 seconds.
+    int result=30;
+    if (QFile::exists(confpath))
+    {
+        QSettings confinfo(confpath,QSettings::IniFormat);
+        QString tmp_TimeOut = confinfo.value("/basic_auth_config/expand_time").toString();
+        if (!tmp_TimeOut.isEmpty())
+            result = tmp_TimeOut.toInt()*60;
+    }
+    return result;
+}
+
+bool WorkerDaemon::judgeAuthen()
+{
+    //Determine whether authentication is required
+    //get PID of deepin_deb_installer 
+    QProcess process;
+    QStringList options;
+    QString tmp_PID("");
+
+    options<<"-c" <<"ps aux --sort -uid |grep deepin-deb-installer |head -n 1 |awk '{print $2}'";
+    process.start("/bin/bash", options);
+    process.waitForFinished();
+    tmp_PID = process.readAllStandardOutput();
+    tmp_PID.remove(QChar('\n'), Qt::CaseInsensitive);
+    
+    //judge if need to get the user authentication.
+    if (m_Deepin_deb_installer_PID != tmp_PID.toInt())
+    {
+        //if tmp_PID != m_Deepin_deb_installer_PID , means the deepin_deb_installer is reopen and need
+        //to get the user authentication.
+        m_Deepin_deb_installer_PID = tmp_PID.toInt();
+        return true;
+    }
+    else
+    {
+        //if pid is the same. Then need to judge the difference between the last authentication time 
+        //and current time, if it is greater than the set value, means need to get user authentication.
+        quint64 currentTime = QDateTime::currentMSecsSinceEpoch();
+        if (currentTime - m_TransTimer > m_IDLE_TIMEOUT)
+        {
+            return true;
+        }
+    }
+    return false;
+}
+
 Transaction *WorkerDaemon::createTransaction(QApt::TransactionRole role, QVariantMap instructionsList)
 {
     int uid = dbusSenderUid();
 
     // Create a transaction. It will add itself to the queue
-    Transaction *trans = new Transaction(m_queue, uid, role, instructionsList);
+    Transaction *trans = new Transaction(m_queue, uid, role, instructionsList, this);
     trans->setService(message().service());
 
     return trans;
Index: libqapt-3.0.4.6/src/worker/workerdaemon.h
===================================================================
--- libqapt-3.0.4.6.orig/src/worker/workerdaemon.h
+++ libqapt-3.0.4.6/src/worker/workerdaemon.h
@@ -41,11 +41,19 @@ class WorkerDaemon : public QCoreApplica
 public:
     WorkerDaemon(int &argc, char **argv);
 
+    void setTransTimer(quint64 timer);
+    bool judgeAuthen();
+    //get idle timeout from config file
+    int getIdleTimeout();
+
 private:
     TransactionQueue *m_queue;
     AptWorker *m_worker;
     QThread *m_workerThread;
     QTimer *m_idleTimer;
+    quint64 m_TransTimer;
+    quint64 m_Deepin_deb_installer_PID;
+    quint64 m_IDLE_TIMEOUT;
 
     int dbusSenderUid() const;
     Transaction *createTransaction(QApt::TransactionRole role,
